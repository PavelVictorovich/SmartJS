# Задания к модулю #3
Этот файл содержит все актуальные задания к модулю #3.
Пожалуйста, присылайте **каждое** задание в **отдельном** письме. Темой письма должен быть номер задания. В письме во вложении должен быть один файл имеющий расширение **js** либо **txt** собственно содержащий решение данного задания.

Перед тем как отсылать Ваши готовые решения, пожалуйста проверьте следующее:

* что ваша функция/функции называются так как требуется в задании
* что ваша функция выводит то что требуется в задании
* что ваша функция выводит данные в требуемом формате


## 3.1 Zen Garden
[Ссылка на архив](https://d1b10bmlvqabco.cloudfront.net/attach/i0xi020wwpp3td/i0xi3o10doh4k8/i1981balteiz/csszen.tar.gz)

В архиве вы найдете файл `index.html`. Откройте его. Видите справа панель? Ваша задача обеспечить ее функциональность в рамках следующей логики:

- При вводе селектора и нажатии кнопки найти подсветить первое совпадение по данному селектору (селектором считается любой валидный CSS-селектор)
Подсветка здесь и далее осуществляется путем
```css
{
  outline: solid red 5px;
  background-color: lightblue;
}
```

- Если относительно текущего подсвеченного элемента существуют предыдущий и следующий элемент удовлетворяющий этому селектору соответственно, то кнопки "Следующий" и "Предыдущий" должны быть доступны и (соответственно) переводить подсветку на предыдущий или следующий элемент

- Использование любых кнопок во второй половине панели отключает навигацию по предыдущим / следующим элементов до нового поиска по селектору

- Кнопки во второй половине панели должны быть доступны если возможен переход на соответствующий элемент (вверх  по dom-дереву, к первому ребенку, к следующему элементу на том же уровне вложенности, к предыдущему элементу на том же уровне вложенности)

Обратите внимание, вам запрещено изменять index.html. Единственное, что Вы можете и должны добавить - подключение js файла в index.html перед закрывающим тегом <body>

## 3.2 I like to move it (часть 1)
Реализовать функцию `makeMovable(element)`, которая принимает на вход DOM-узел и обеспечивает его перетаскивание с помощью мышки.

[Код, реализовывающий перетаскивание с лекции ](https://gist.github.com/xanf/12f665eaf135b1a6c591)

Вы можете предполагать, что все элементы, которые мы будем пытаться делать movable абсолютно отпозиционированы. Однако, Вам необходимо учесть тот факт, что исходные элементы, которые делаются movable могут иметь в CSS изначальное позиционирование (с помощью right, left, top, bottom к примеру). Этим это задание отличается от примера, который мы разбирали в зале - там элемент всегда начинал свой путь с 0,0.

Также, необходимо запретить перетаскивание элемента за пределы его контейнера. Для теста вы можете дать контейнеру overflow: auto и скроллы у вас никогда не должны появляться.

## 3.3 I like to move it (часть 2)
Реализовать функцию `makeMovable2(element)`, которая принимает на вход DOM-узел и обеспечивает его перетаскивание с помощью мышки.

Все предположения из 3.2 остаются в силе. Теперь добавляется дополнительное условие: если у нас внутри movable элемента есть тоже movable элементы, то при перетаскивании **внешнего** элемента, внутренние элементы должны визуально оставаться на месте на экране. Поскольку все ограничения из 3.2 в силе, то при перетаскивании внешнего контейнера вы не должны дать появиться скроллам из-за того, что внутренние элементы остаются на месте. Фактически, ваши внутренние элементы теперь ограничивают движения внешнего контейнера
## Без номера. Полеты во сне и наяву: часть 0

Создайте HTML-страницу на которой будет два дива:
+ `id=container` - высотой и шириной в 95vh и 95vw соответственно. Дайте ему border
+ `id=flyer` - высотой и шириной в 50 px. Выставьте его border-radius таким, чтобы он превратился в окружность. Абсолютно отпозиционируйте его внутри контейнера.

Напишите код, который заставит ваш `flyer` летать, отбиваясь от стенок div'а. Соблюдайте школьные законы физики. Угол падения равен углу отражения.

## 3.4 Полеты во сне и наяву: часть 1
Воспользуйтесь страницей из предыдущего задания. Удалите `#flyer`. Вместо этого напишите скрипт, который при загрузке страницы создаст случайное количество (от 10 до 20) div'ов с классом `.flyer` разных цветов, разных радиусов (от 25 до 75px) и разных скоростей (от 10 до 100px в секунду). Эти div'ы должны летать по контейнеру, сталкиваясь между собой. Соблюдайте законы физики (закон сохранения импульса)

## 3.5 Полеты во сне и наяву: часть 2
Воспользуйтесь решением задачи 3.4. Сделайте анимацию максимально плавной используя `window.requestAnimationFrame`.

## 3.6 Simple AJAX
Реализовать файл `index.js`, обеспечивающий следующую функциональность:
+ при загрузке страницы в div с классом `.list` выводится список пользователей. Каждый элемент списка - имя пользователя, представляющее собой гиперссылку, при клике на которой открывается форма написания письма этому пользователю (`mailto:`). При наведении на гиперссылку отображается `username` этого поьзователя
+ после получения ответа на AJAX-запрос в span `.loadtime` отображается время, затраченное на выполнение запроса (в миллисекундах)
+ при нажатиии на кнопку `.reload` выполняется повторная загрузка списка с сервера (включая оба предыдущих пункта)

URL для выполнения запроса: `http://jsonplaceholder.typicode.com/users`
Метод запроса: конечно же `GET`

## 3.7 Wikipedia
Чтобы сэкономить вам время - основу для верстки можете взять [здесь](http://jsfiddle.net/rgkk5oLs/2/)
Изменять HTML / CSS задания нельзя.
Запрещено писать код вне зоны "ваш код располагается здесь"

Ваша задача реализовать JSONP-запрос к серверам Википедии. При клике на кнопку считайте название статьи введенное в поле (по умолчанию JavaScript), загрузите ее с сервера Википедии и отобразить в диве с id `content`.
 
Для этого вам необходимо:
+ помнить как работает JSONP
+ определить глобальную функцию, которая будет обрабатывать ответ. Ей на вход прийдет один параметр, назовем его data, дать ей имя.
+ создать новый тег скрипт внутри JS (createElement)
+ выставить его src в `http://en.wikipedia.org/w/api.php?action=parse&page=title&prop=text&section=0&format=json&callback=func` . `Title` необходимо заменить на имя страницы, введенное в поле ввода, `func` - на имя вашей функции созданной на этапе 2
+ внутри определенной вами глобальной функции вывести результат. Искомый текст находится внутри объекта `data` в поле `parse`, в поле `parse` находится поле `text`, в поле `text` находится поле `*` (да, оно называется звездочка. Нет, это не я придумал. Так отдает википедия. Смерть в яйце, яйцо в зайце, заяц в уттке, утка в шоке)
+ если изменить текст в поле ввода и нажать Go - естественно должна загрузиться следующая статья
 
## 3.B1 Wikipedia-Crawler
**Внимание!** Это бонусное задание. Его выполнение не обязательно, но крайне полезно.

Реализовать функцию `searchWiki(term1, term2, cb)`. Функция принимает на вход term1 и term2 - имена статей Википедии (английской) между которыми надо искать связь. Если связь найдена - вызвать функцию, переданную в cb с единственным аргументом - массивом имен статей, обозначающих связь. Если связь не найдена длиной 2 (т.е. вы просмотрели 2 уровня вложенности от основной статьи) - вызвать cb с параметром null

Пример:
```js
searchWiki('Microsoft', 'Combinatorics, function (res) {
  console.log (res);
});
// ожидаемый результат:
// ['Microsoft', 'Bill_Gates', 'Combinatorics']
```

Алгоритм решения:
+ получите статью из Википедии
+ проверьте, нет ли в ней ссылки на нужную Вам статью
+ если ссылки нет - вычлените из статьи все ссылки на другие статьи Википедии, поместите в очередь, повторите

Подводные камни:
+ помните, что ходить по кругу плохо. Храните список уже просмотренных статей, иначе вы зациклитесь
+ при фильтровании ссылок не забудьте, что не все ссылки в статье на Википедии ведут на другие статьи Википедии
+ помните, что вы не сможете применить подход с очередью "в лоб" - ведь после того как вы отправили запрос вам необходимо будет дождаться его завершения

Решение этого задания будет выложено 1 марта 2016 года. У вас есть время до этого срока. Успехов!

