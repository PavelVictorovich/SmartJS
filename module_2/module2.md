# Задания к модулю #2
Этот файл содержит все актуальные задания к модулю #2.
Пожалуйста, присылайте **каждое** задание в **отдельном** письме. Темой письма должен быть номер задания. В письме во вложении должен быть один файл имеющий расширение **js** либо **txt** собственно содержащий решение данного задания.

Обратите внимание, что требования в некоторых заданиях слегка изменены, поэтому перед тем как отсылать Ваши готовые решения, пожалуйста проверьте следующее:

* что ваша функция/функции называются так как требуется в задании
* что ваша функция выводит то что требуется в задании
* что ваша функция выводит данные в требуемом формате


Если вы присылали домашние задания второго модуля, пожалуйста вышлите их еще раз, указав правильную нумерацию (даже если каким-то чудом вы угадали правильный номер задания). Заранее спасибо.

## 2.1 Работа со списками
Реализовать в глобальной области видимости объект list со следующими методами:

`add(l, v)` - добавляет в список l значение value в конец

`remove(l, index)` - удаляет из списка l элемент по индексу index (индексация с 0)

`create()` - функция, которая ничего не принимает и что-то возвращает. Возвращает новый пустой список

`search(l, v)` - ищет в списке l значение v и возвращает ссылку на элемент списка с этим значением если оно есть, в противном случае возвращает null

`isEmpty(l)` - возвращает `true` если список пустой (содержит 0 элементов) и `false` -  если непустой

`insertAt(l, v, i)` - вставляет в список l значение v по индексу i

`toArray(l)` - преобразовывает список в массив. Возвращает массив

`size(l)` - возвращает количество элементов списка

`get(l, i)` - возвращает I-ый элемент списка или false если такой не найден

Список храним как объект, состоящий из двух полей:
```js
{
  value: 'здесь хранится само значение',
  next: 'ссылка на следующий элемент списка или null'
}
```
Пример работы со списком:
```js
var x = list.create();
list.add(x, 1);
list.add(x, 3);
list.add(x, 5);
console.log(list.toArray(x); // [1, 3, 5]
console.log(list.size()); // 3
list.remove(x, 1);
console.log(list.toArray(x); // [1, 5]
list.add(x, 8);
list.add(x, 10);
console.log(list.toArray(x); // [1, 5, 8, 10]
list.insertAt(l, 2, 11);
console.log(list.toArray(x); // [1, 5, 11, 8, 10]
console.log(list.search(l, 11));
/*
{
  value: 11,
  next: {
    value: 8,
    next: {
      value: 10,
      next: null
    }
  }
}
*/
```
Вы вправе реализовывать эти функции используя другие функции, за единственным исключением: функция toArray не может исполььзоваться в других функциях (она добавлена исключительно в отладочных целях)

## 2.2 Обратная польская нотация: подсчет
Реализовать функцию rpn вычисляющую выражение, переданное вам в [обратной польской нотации](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C)

Вам на вход будет передан массив, содержащий выражение в обратной польской нотации. Каждый элемент массива представляет собой либо число, либо один из четырех математических знаков

Ваша функция должна вернуть вычисленное значение, либо false - если выражение сформированно некорректно.
Пример:

```js
console.log(rpn([1, 2, '+'])); // 3
console.log(rpn([1, 2, '+', 5, '*'])); // 15
console.log(rpn([1, 2, '+', 5])); // false
console.log(rpn([1, 2, '+', '*'])); // false
console.log(rpn([1, 2, 3, '*', '+'])); // 7
```

## 2.3 Обратная польская нотация: преобразование
_это задание повышенной сложности, рекомендуем приступать к нему после окончания всех простых заданий_

Реализуйте функцию **convert**, которая преобразовывает строку в “человеской нотации” в обратную польскую нотацию. Вывод этой функции должен быть идентичен формату ввода в задании 2.2

[Алгоритм преобразования](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C#.D0.9F.D1.80.D0.B5.D0.BE.D0.B1.D1.80.D0.B0.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.B8.D0.B7_.D0.B8.D0.BD.D1.84.D0.B8.D0.BA.D1.81.D0.BD.D0.BE.D0.B9_.D0.BD.D0.BE.D1.82.D0.B0.D1.86.D0.B8.D0.B8)

Вы можете быть уверены в следующих утверждениях касательно строк, подаваемых на вход вашей функции convert:
* все выражения, подаваемые на вход будут корректными математическими выражениями. Ситуации когда у Вас на входе два числа подряд, или незакрытая скобка - рассматривать не надо
* все выражения, подаваемые на вход будут "красиво" отформатированы. Это значит что математические знаки будут отделены с двух сторон ровно одним пробелом (кроме скобок конечно же)

Также советую помнить о паре вещей:
* 2.5 тоже вполне себе число :)
* -2.5 тоже число (т.е. не путайте отрицательное число с операцией вычитания)

## 2.4 Связный граф
Вам задан граф. Ответить, является ли он связным (из любой вершины можно попасть в любую другую. Граф считать неориентированным, т.е. если в списке ребер встречается ребро [1, 2] - это означает что есть путь как из 1 в 2, так и из 2 в 1.

Граф задается как массив объектов с полями from и to. Ваша функция **check** должна выводить true или false

Пример:
```js
var graph = [
	{ from: 1, to: 2},
	{ from: 3, to: 1},
	{ from: 8, to: 1 },
	{ from: 2, to: 4 },
	{ from: 8, to: 4 },
	{ from: 3, to: 4 },
	{ from: 4, to: 5 },
	{ from: 4, to: 6 },
	{ from: 7, to: 4 },
	{ from: 5, to: 6 },
	{ from: 5, to: 7 }
]
console.log(check(graph)) // true
```

Алгоритм решения задачи:
+ Завести массив, в котором по индексу Х будет храниться “цвет вершины” графа.
```js
var colors = [];
```
+ Взять первое ребро графа. “Покрасить” вершины упомянутые в нем (в нашем случае 1 и 2) в цвет “1” (просто записать туда 1)
```js
// colors = [undefined, 1, 1]
```
+ Пройтись циклом по всем ребрам графа, и если в массиве цветов from или to “покрашено” в цвет “1” - то и from и to в массиве colors покрасить в цвет “1”. Так после первого прохода массива “покрасятся” вершины 3 (ребро **3-1**), 8 (**8-1**), 4 (**2-4**)
+ Повторять шаг 3 пока на каждом просмотре массива мы хотя бы что-то покрасили
+ Пройтись по итогому массиву colors - у **всех** вершин (в нашем случае от 1 до 8) должен быть одинаковый цвет “1”
+ Готово :)

## 2.5 Алгоритм Дейкстры
Реализуйте функцию **djkstra**, принимающую на вход три аргумента: from - номер вершины **из** которой надо построить путь, **to** - номер вершины в которую надо построить путь, **paths** - массив ребер графа. Граф считать двунаправленным (т.е. если путь есть из from в to, то из to в from) тоже есть. Функция должна возвращать **путь** из вершины **from** в вершину **to** если таковой имеется, либо false - если не имеется

Пример:
```js
var paths = [
  {
    from: 1,
    to: 2,
    price: 7
  },
  {
    from: 1,
    to: 3,
    price: 9
  },
  {
    from: 6,
    to: 1,
    price: 14
  },
  {
    from: 2,
    to: 3,
    price: 10
  },
  {
    from: 4,
    to: 2,
    price: 15
  },
  {
    from: 4,
    to: 3,
    price: 11
  },
  {
    from: 5,
    to: 4,
    price: 6
  },
  {
    from: 5,
    to: 6,
    price: 9
  },
  {
    from: 6,
    to: 3,
    price: 2
  }
];

console.log(djkstra(1, 4, paths));
//[1, 3, 4]
console.log(djkstra(1, 5, paths));
//[1, 3, 6, 5]
```
## 2.6 Алгоритм Флойда-Уоршолла (часть 1)
Реализуйте функцию **floyd1**, принимающую на вход один аргумент **paths** - массив ребер графа с их стоимостью. Граф считать двунаправленным (т.е. если путь есть из from в to, то из to в from) тоже есть. Функция должна выводить на консоль **строку**, которая представляет собой матрицу расстояний между вершинами графа. Если пути из вершины **a** в вершину **b** нет - в матрице должно быть пустое место. Матрица должна быть "красиво" отформатирована отступами для отображения.

Пример:
```js
var paths = [
  {
    from: 1,
    to: 2,
    price: 7
  },
  {
    from: 1,
    to: 3,
    price: 9
  },
  {
    from: 6,
    to: 1,
    price: 14
  },
  {
    from: 2,
    to: 3,
    price: 10
  },
  {
    from: 4,
    to: 2,
    price: 15
  },
  {
    from: 4,
    to: 3,
    price: 11
  },
  {
    from: 5,
    to: 4,
    price: 6
  },
  {
    from: 5,
    to: 6,
    price: 9
  },
  {
    from: 6,
    to: 3,
    price: 2
  }
];

floyd1(paths);
/*
14  7  9 20 20 11
 7 14 10 15 21 12
 9 10  4 11 11  2
20 15 11 12  6 13
20 21 11  6 12  9
11 12  2 13  9  4
*/
```
## 2.7 Алгоритм Флойда-Уоршолла (часть 2)
Реализуйте функцию **floyd2**, принимающую на вход один аргумент **paths** - массив ребер графа с их стоимостью. Граф считать двунаправленным (т.е. если путь есть из from в to, то из to в from) тоже есть. Функция должна выводить на консоль **набор строк**, каждая из которых отображает самый оптимальный путь из вершины 1 во все вершины, далее самый оптимальный путь из вершины 2 во все вершины кроме 1 и т.д. Если пути из вершины в вершину нет - выводить "no way" вместо пути

Пример:
```js
var paths = [
  {
    from: 1,
    to: 2,
    price: 7
  },
  {
    from: 1,
    to: 3,
    price: 9
  },
  {
    from: 6,
    to: 1,
    price: 14
  },
  {
    from: 2,
    to: 3,
    price: 10
  },
  {
    from: 4,
    to: 2,
    price: 15
  },
  {
    from: 4,
    to: 3,
    price: 11
  },
  {
    from: 5,
    to: 4,
    price: 6
  },
  {
    from: 5,
    to: 6,
    price: 9
  },
  {
    from: 6,
    to: 3,
    price: 2
  }
];

floyd2(paths);
/*
1 --> 2: 1 2
1 --> 3: 1 3
1 --> 4: 1 3 4
1 --> 5: 1 3 6 5
1 --> 6: 1 3 6
2 --> 3: 2 3
2 --> 4: 2 4
2 --> 5: 2 3 6 5
2 --> 6: 2 3 6
3 --> 4: 3 4
3 --> 5: 3 6 5
3 --> 6: 3 6
4 --> 5: 4 5
4 --> 6: 4 3 6
5 --> 6: 5 6
*/
```
## 2.8 Двоичное дерево поиска
Реализовать двоичное дерево поиска. В глобальной области видимости должно быть несколько функций:

`create (value)` - возвращает объект
```js
{ value: value, left: null, right: null }
```

`add(tree, value)` - добавляет объект в упорядоченное бинарное дерево (примените рекурсию!)

`search(tree, value)` - ищет объект в упорядоченном бинарном дереве. возвращает true или false если примитивное значение value найдено в дереве в полях value (примените рекурсию!)

`print(tree)` - выводит дерево на экран в следующем порядке:
* левое поддерево
* корень
* правое поддерево

`remove(tree, value)` - удаляет узел из дерева со значением value. Можете считать, что Вас никогда не заставят удалять последний элемент из дерева, однако учтите, что ситуация с удалением корня дерева - вполне возможна

Вам **не надо** обрабатывать ситуацию, когда вам в дерево приходит более одного элемента с одинаковым value

Пример работы:
```js
var t  = create(8);
// t = {value: 8, left: null, right: null }
add(t, 10);
/*
t = {
  value: 8,
  left: null,
  right: {
    value: 10,
    left: null,
    right: null
  }
}
*/
add(t, 3);
/*
t = {
  value: 8,
  left: {
    value: 3,
    left: null,
    right: null
  },
  right: {
    value: 10,
    left: null,
    right: null
  }
}
*/
add(t, 1);
add(t, 6);
add(t, 4);
add(t, 7);
add(t, 14);
add(t, 13);

print(t);
// 1 3 4 6 7 8 10 13 14
```
## 2.9 Красно-черные деревья
_это задание повышенной сложности, рекомендуем приступать к нему после окончания всех простых заданий_

Реализуйте следующие вещи:

+ Функцию `checkTree` которая возвращает `true` если дерево является корректным красно-черным деревом и `false` если является некорректным

+ Функцию `singleRotate(node, direction)` которая осуществляет единичное вращение узла

+ Функцию `doubleRotate(node, direction)` которая осуществляет двойное вращение узла

+ Функцию добавления узла `addNode` которая добавляет узел в дерево (вам понадобятся три сценария:
  + перекраска
  + одиночное вращение
  + двойное вращение

Удаление узла реализовывать не нужно

Вам поможет https://www.dropbox.com/s/z2g79re4tof2wsk/visualizer.zip?dl=0

Внимание, важная подсказка по реализации функции `addNode`. Прежде всего ознакомьтесь с алгоритмом добавления узла в красно-черное дерево на просторах интернета. Вы обнаружите важную особенность: когда вы добавляете новый узел в дерево, вы красите его в какой-то конкретный цвет. При этом "ошибка" (нарушение правил дерева) возникает в родителе и т.д. Более того, любой алгоритм добавления оперирует понятием "дяди" - брата родителя. Все это приводит к тому, что хорошо бы иметь возможность двигаться по дереву не только вниз (по left / right) а еще и вверх (по родителям). Так давайте добавим в каждый узел ссылку на его родителя. Как-то так:
```js
function addParents(tree) {
  if (tree.left) {
    tree.left.parent = tree;
    addParents(tree.left);
  }
  if (tree.right) {
    tree.right.parent = tree;
    addParents(tree.right);
  }
}
```
