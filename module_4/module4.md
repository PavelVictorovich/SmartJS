# Задания к модулю #4

Этот файл содержит все актуальные задания к модулю #4. Пожалуйста, присылайте каждое задание в отдельном письме. Темой письма должен быть номер задания. В письме во вложении должна быть единственная ссылка на решение вашего задания на сервисе http://jsbin.com

# 4.1 It's complex (Все сложно)
Реализовать класс `Complex` для работы с комплексными числами.
Комплексное число представляется парой действительных чисел (a,b), где a-действительная часть, b-мнимая часть. Реализовать класс Complex для работы с комплексными числами. Обязательно должны присутствовать операции:

1. сложения `add`, (a,b)+(c,d)=(a+c,b+d);
2. вычитания `sub`, (a,b)-(c,d)=(a-c,b-d);
3. умножения `mul`, (a,b)x(c,d)=(ac-bd,ad+bc);
4. деления `div`, (a,b)/(c,d)=(ac+bd,bc-ad)/(c^2+d^2);
5. сравнение `equ`, (a,b)=(c,d),если (a=c) и (b=d);
6. сопряженное число `conj`, conj (a,b)=(a,-b).

Операции 1-4 и 6 должны возвращать новое комплексное число как результат
Все операции должны принимать на вход как комплексные числа, так и обычные Number.
Реализовать все необходимые проверки.

# 4.2 Упражнения с плоскостью
Реализовать класс `Point`, хранящий в себе две координаты: `x` и `y` - координаты точки на плоскости.
Реализовать класс `Segment` представляющий собой отрезок, имеющий в себе две точки `start` и `end`. Класс отрезка должен иметь метод `intersects`, принимающий на вход другой отрезок и возвращающий `Point` их пересечения, либо null, если отрезки не пересекаются.

Реализовать класс `Polygon`, представляющий собой массив отрезков, конец предыдущего совпадает с началом последующего. Конец последнего совпадает с началом первого.
Класс  должен иметь метод `render`, принимающий на вход DOM узел типа `svg` и цвет в `HEX` (`#445566`) и рисующий многоугольник в этом svg заданным цветом.

Класс `Polygon` должен иметь метод `intersects`, принимающий на вход другой `Polygon` и возвращающий массив `Point`, описывающий точки пересечения этих двух многоугольников, либо null, если они не пересекаются.
Реализовать все необходимые проверки.

# 4.B1 Пересечения многоугольников
Измените код предыдущего задания так, что метод `intersects`, возвращает массив `Polygon`, описывающий пересечение этих двух многоугольников, либо null, если они не пересекаются.

# 4.3 Simple CRUD

Реализуйте базовый класс `Collection`, со следующей логикой:

* У объекта `Collection` должно быть поле `url` в котором хранится адрес для получения коллекции ( к примеру `http://jsonplaceholder.typicode.com/todos`)
* У объекта `Collection` должен быть метод `list(callback)`, который осуществляет `GET` запрос на URL, указанный в поле `url` и принимает на вход `callback`. После завершения запроса необходимо вызвать `callback` с массивом экземпляров `Collection` вторым аргументом. Первым аргументом является ошибка, возникшая при загрузке
* `Collection` должен иметь конструктор, принимающий на вход один параметр - объект и копирующий все его поля в this
* У экземпляра `Collection` должен быть метод `save(cb)`, работающий по следующей логике:
    *  если у экземпляра `Collection` нет id - то необходимо выполнить `POST` запрос на `url`. Содержимое запроса - все поля текущего экземпляра `Collection`. В ответе необходимо получить `id` и сохранить его в экземпляр `Collection`
    *  если у экземпляра `Collection` есть `id` - то необходимо выполнить `PATCH` запрос на `${url}/${id}`. В запрос необходимо включить только **измененные** поля экземпляра `Collection` с момента последнего вызова `save`
    *  `cb` вызывается после того, как сохранение было успешно завершено. Единственный параметр `cb` - ошибка, возникшая при сохранении или `null`
* У объекта `Collection` должен быть метод `get(id, callback)`, который осуществляет `GET` запрос на URL, `${url}/${id}`. После завершения запроса необходимо вызвать `callback` с экземпляром `Collection` первым аргументом. Первым аргументом является ошибка, возникшая при загрузке

Реализовать следующую логику приложения:

* Реализовать класс `User` унаследованный от `Collection`. Класс `User` должен иметь методы `list` и `get` аналогичные `Collection`, но возвращающий экземпляры класса `User`
* Класс `User` должен иметь поле `url` `http://jsonplaceholder.typicode.com/users`
* При сохранении пользователя необходимо проверить следующие утверждения:
    * у пользователя выставлены поля `name`, `username` и `email`
    * у пользователя `email` является корректным адресом электронной почты
* Реализовать класс `User` унаследованный от `Collection`. Класс `User` должен иметь методы `list` и `get` аналогичные `Collection`, но возвращающий экземпляры класса `User`
* Класс `User` должен иметь поле `url` `http://jsonplaceholder.typicode.com/users`
* При сохранении пользователя необходимо проверить следующие утверждения:
    * у пользователя выставлены поля `name`, `username` и `email`
    * у пользователя `email` является корректным адресом электронной почты
* Реализовать класс `Album` унаследованный от `Collection`. Класс `Album` должен иметь методы `list` и `get` аналогичные `Collection`, но возвращающий экземпляры класса `Album`
* Класс `Album` должен иметь поле `url` `http://jsonplaceholder.typicode.com/albums`
* При сохранении альбома необходимо проверить следующие утверждения:
    * у альбомы выставлены поля `userId`, `title`
* Реализовать класс `Photo` унаследованный от `Collection`. Класс `Photo` должен иметь методы `list` и `get` аналогичные `Collection`, но возвращающий экземпляры класса `Photo`
* Класс `Photo` должен иметь поле `url` `http://jsonplaceholder.typicode.com/photos`
* Экземпляры класса `User` должен иметь метод `getAlbums(cb)`, который возвращает массив `Album`, принадлежащих пользователю
* Экземпляры класса `Album` должен иметь метод `getPhotos(cb)`, который возвращает массив `Photo`, принадлежащих альбому
* Реализовать следующую логику на странице:
    * При загрузке отображается список имен пользователей
    * При клике по имени пользователя отображается список его альбомов
    * При клике по имени альбома отображается список фото в нем (используйте `thumbnailUrl`)
    * При клике по фото, оно открывается полноразмерно в новом окне

# 4.4 Реактивное TODO. Часть 1
```js
const todos = {
    1: {done: false, text: 'Решить все задания 4 модуля' },
    2: {done: false, text: 'Заплатить за 5 модуль' },
    3: {done: false, text: 'Победить лень' },
    4: {done: false, text: 'Захватить мир' }
};

const todoList = new TodoList({
    todos,
    node: document.querySelector('todos'),
    onTodoStateChanged: function (id) {
        this.todos = {
            ...this.todos,
            [id]: { ...this.todos[id], done: !this.todos[id].done }
        };
    },
    onTodoRemoved: function (id) {
        const newTodos = { ...this.todos };
        delete newTodos[id];
        this.todos = newTodos;
    },
    onTodoAdd: function (text) {
        this.todos = {
            ...this.todos,
            [Math.random().toString(16).substr(2)]: { done: false, text }
        };
    }
});
  
```
## Детали реализации
Класс TodoList должен иметь метод `render`, который отрисовывает содержимое объекта `this.todos`. Как отрисовывает - дело за Вами, можете вдохновиться http://todomvc.com/examples/vanillajs/#/
Функция `render` **полностью** очищает DOM-узел `node` перед отрисовкой

* Когда пользователь щелкает по чекбоксу (слева) - вы должны вызвать переданную вам в параметрах функцию `onTodoStateChanged`, передав ей в качестве `this` ваш экземпляр класса, а в параметре - id todo по которой щелкнули
* Когда пользователь щелкает по крестику (справа) - вы должны вызвать переданную вам в параметрах функцию `onTodoRemoved`, передав ей в качестве `this` ваш экземпляр класса, а в параметре - id todo по которой щелкнули 
* Когда пользователь вводит текст нового todo и нажимает Enter - вы должны вызвать переданную вам в параметрах функцию `onTodoAdd`, передав ей в качестве `this` ваш экземпляр класса, а в параметре - введенный пользователем текст
* При изменении поля `todos` в объекте - метод `render` должен вызываться автоматически 

# 4.5 Светофор
Описание будет добавлено позже

# 4.6 Художник
Помните задание с movable? Когда мы перетаскивали кружочки по div'у. Время сделать его интереснее. Что я хочу:
- при загрузке страницы на всей странице (выставьте height/width 100% у html и body) в произвольных местах создаются 10 кругов одинакового радиуса со случайными цветами в HEX. **Они располагаются так, чтобы не пересекаться друг с другом**
- все 10 кругов movable
- при двойном клике по кругу он исчезает
- при двойном клике по пустому месту на странице в этой точке создается круг, с центром в точке клика ЕСЛИ новый круг не будет пересекаться с другими кругами
- если перетаскивание заканчивается наложением на другой круг, и расстояние между центрами кругов меньше половины радиуса - то эти два круга удаляются, а вместо них создается новый круг, цвет которого является средним цветом двух кругов, учавствовавших в слиянии, а позиция - усредненные координаты двух кругов

Детали реализации: Вам понадобятся два класса: класс окружности, который будет хранить координаты центра круга, ее цвет и DOM узел. У него будет конструктор, который при создании будет получать на вход координаты, создавать в этой точке круг (DOM-узел) и вешать на него обработчики перетаскивания.

Второй класс это "поле". В нем вы будете делать следующие вещи: реализовывать обработчик двойного клика (в зависимости от targetа смотрим что должны делать - создавать новый круг или удалять старый), содержать список всех кругов которые у нас есть (экземпляры класса), проверять на пересечения и считать расстояние между кругами

Описание деталей реализации сознательно не является полным, поэтому прежде чем писать хотя бы строчку кода, сядьте и подумайте на бумаге или еще где-то какие у вас методы и поля будут в каждом классе и как это все будет работать. В идеале - расскажите об этом ментору и получите его утверждение. Это финальное задание 4 модуля и основная проблема здесь - не код, а то как все это разложить по полочкам. Не спешите писать код, общайтесь. И да, **не храните** ничего в data-аттрибутах. Это неуместно